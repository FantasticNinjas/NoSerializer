
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// @file Test.hxx
///
/// @brief Simple C++ unit testing framework; compatible with any version of C++ and depends only on the STL.
/// @details Unfortunately, the most popular C++ testing frameworks (GoogleTest and Catch) require C++ 11, and are
///          therefore unsuitable for testing compatibility with C++98 for the public interface. This home-grown
///          is not nearly as full-featured as either of them, but it is easy enough to work with and suites the needs
///          of the project.
///
/// @note Basic usage:
///       BASIC_TEST(testGroupName, testName) - Declares a test function
///       FIXTURE_TEST(testGroupName, testName, fixtureName) - Declares a unit test with class fixtureName as a fixture
///       EXPECT(condition) - Fails the current test (but continues execution) if condition is false
///       ASSERT(condition) - Fails the current test (and continues on to the next test) if condition is false
///       EXPECT_EXCEPTION(statement, exceptionType) - Fails the current test (but continues execution) if an exception
///                                                    of type exceptionType is not thrown by statement
///       ASSERT_EXCEPTION(statement, exceptionType) - Fails the current test (and continues on to the next test) if an
///                                                    exception of type exceptionType is not thrown by statement
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef NOSERIAL_TEST
#define NOSERIAL_TEST

#include <vector>
#include <string>
#include <iostream>
#include <exception>

// ANSI formatting codes for console output
#define COLOR_GREEN "\033[1;92m"
#define COLOR_RED "\033[1;91m"
#define COLOR_NORMAL "\033[0m"

/////////////////////////////////////////////////////////////
/// @brief Base class for everything that can be run as a test.
/////////////////////////////////////////////////////////////
class Test
{
public:
    /////////////////////////////////////////////////////////////
    /// @brief Virtual destructor
    /////////////////////////////////////////////////////////////
    virtual ~Test()
    {}

    /////////////////////////////////////////////////////////////
    /// @brief Perform the actual test. This should always be called by TestManager, as the ASSERT and EXPECT macros
    ///        report directly back to the TestManager, not to the test.
    /////////////////////////////////////////////////////////////
    virtual void runTest() = 0;

    /////////////////////////////////////////////////////////////
    /// @brief Get the name of this test as a string
    /////////////////////////////////////////////////////////////
    virtual const std::string& getTestName() const = 0;

    /////////////////////////////////////////////////////////////
    /// @brief Get the test group this test is a part of as a string
    /////////////////////////////////////////////////////////////
    virtual const std::string& getTestGroup() const = 0;
};

/////////////////////////////////////////////////////////////
/// @brief Wrapper arround Test that allows tests to be stored in an std::vector (which is otherwise not possible for)
///        polymorphic types
/////////////////////////////////////////////////////////////
class TestWrapper
{
public:
    /////////////////////////////////////////////////////////////
    /// @brief Create a TestWrapper around an existing Test
    /////////////////////////////////////////////////////////////
    TestWrapper(Test* test) : test(test)
    {}

    /////////////////////////////////////////////////////////////
    /// @brief Run the test
    /////////////////////////////////////////////////////////////
    void operator()()
    {
        test->runTest();
    }

    /////////////////////////////////////////////////////////////
    /// @brief Get the name of this test as a string
    /////////////////////////////////////////////////////////////
    const std::string& getTestName() const
    {
        return test->getTestName();
    }

    /////////////////////////////////////////////////////////////
    /// @brief Get the test group this test is a part of as a string
    /////////////////////////////////////////////////////////////
    const std::string& getTestGroup() const
    {
            return test->getTestGroup();
    }

private:
    Test* test; //<! Pointer used internally to store the actual test
};

/////////////////////////////////////////////////////////////
/// @brief Represents a fixture test (i.e a test that is run with an instance of a particular class)
///
/// @param T The fixture class (a subclass of the class provided by the user that is generated by FIXTURE_TEST())
/////////////////////////////////////////////////////////////
template<typename T>
class FixtureTest: public Test
{
public:
    /////////////////////////////////////////////////////////////
    /// @brief Create a new instance of the fixture class and runs the test
    /////////////////////////////////////////////////////////////
    void runTest()
    {
        T fixture;
        fixture.runTest();
    }

    /////////////////////////////////////////////////////////////
    /// @brief Get the name of this test as a string
    /////////////////////////////////////////////////////////////
    const std::string& getTestName() const
    {
        return T::getTestName();
    }

    /////////////////////////////////////////////////////////////
    /// @brief Get the test group this test is a part of as a string
    /////////////////////////////////////////////////////////////
    const std::string& getTestGroup() const
    {
        return T::getTestGroup();
    }

};

/////////////////////////////////////////////////////////////
/// @brief Exception used to exit out of the currently running test without any other effects. Used by ASSERT()
/////////////////////////////////////////////////////////////
class ExitTestException: public std::exception
{};

// Create a local instance of ExitTestException that will be thrown from within tets.
namespace
{
    ExitTestException exitTest;
}

/////////////////////////////////////////////////////////////
/// @brief Singleton in charge of managing and running tests
/// @details Maintains a list of all tests that have been declared, executes them, and keeps track of their results
/////////////////////////////////////////////////////////////
class TestManager
{
public:
    /////////////////////////////////////////////////////////////
    /// @brief Get the singleton instance of TestManager
    /////////////////////////////////////////////////////////////
    static TestManager& getInstance()
    {
        static TestManager instance;
        return instance;
    }

    /////////////////////////////////////////////////////////////
    /// @brief Register a new test with the TestManager
    /////////////////////////////////////////////////////////////
    void registerTest(const TestWrapper& test)
    {
        tests.push_back(test);
    }

    /////////////////////////////////////////////////////////////
    /// @brief Run all tests that have been registered with the TestManager
    ///
    /// @returns Integer status code suitable for the program's exit code: 0 if all tests passed, -1 if one or more 
    ///          failed
    /////////////////////////////////////////////////////////////
    int runAllTests()
    {
        int status = 0;
        std::vector<TestWrapper> failedTests;

        for(auto& test : tests)
        {
            std::cout << COLOR_GREEN  << "Running test \"" << test.getTestName() << "\" from group \"" << 
                    test.getTestGroup() << "\"..." << COLOR_NORMAL << std::endl;

            currentTestSucceeded = true;
            try
            {
                // Run the test
                test();
            }
            catch(const ExitTestException& e)
            {
                // Nothing to do here; ExitTestException means to exit the current test without doing anything else
            }
            catch(const std::exception& e)
            {
                // Fail the test if an unexpected exception occurred
                std::cout << "  Caught an unexpected exception \"" << e.what() << "\"" << std::endl;
                failCurrentTest();
            }
            
            //Report whether or not the test succeeded
            if(currentTestSucceeded)
            {
                std::cout << COLOR_GREEN << "  Success." << COLOR_NORMAL << std::endl;
            }
            else
            {
                std::cout << COLOR_RED << "  Failure." << COLOR_NORMAL << std::endl;
                status = -1;
                failedTests.push_back(test);
            }
        }

        // All tests have been run. Report on whether any of them failed
        if(status == 0)
        {
            std::cout << COLOR_GREEN << "All tests passed!" << COLOR_NORMAL << std::endl;
        }
        else
        {
            std::cout << COLOR_RED << "Some tests failed!" << COLOR_NORMAL << std::endl;

            for(auto& test : failedTests)
            {
                std::cout << COLOR_RED << "  " << test.getTestGroup() << ": " << test.getTestName() << COLOR_NORMAL << 
                        std::endl;
            }
        }

        return status;
    }

    /////////////////////////////////////////////////////////////
    /// @brief Mark the current test as failed
    /////////////////////////////////////////////////////////////
    void failCurrentTest()
    {
        currentTestSucceeded = false;
    }

    /////////////////////////////////////////////////////////////
    /// @brief Stop executing the current test and move on to the next one.
    /////////////////////////////////////////////////////////////
    void exitCurrentTest()
    {
        throw exitTest;
    }

private:
    std::vector<TestWrapper> tests; //<! Vector to store registered tests
    bool currentTestSucceeded; //<! Boolean to keep track of the status of the current test.

    /////////////////////////////////////////////////////////////
    /// @brief Private default constructor, used by getInstance()
    /////////////////////////////////////////////////////////////
    TestManager()
    {}
};



    ////////////////////////////////////////
    //   Macros used for creating tests   //
    ////////////////////////////////////////


// Helper macros for RUN_IMMEDIATELY

// Does the actual work of running the statement immediately. Note that static variables are initialized at the start of
// the program, even if doing so has side-effects
#define RUN_IMMEDIATELY__(statement, uniqueId) \
    namespace { \
        struct runner_##uniqueId \
        { \
            static int runStatement() {statement; return 0;} \
            static int value; \
        }; \
    } \
    int runner_##uniqueId::value = runner_##uniqueId::runStatement()

// Runs RUN_IMMEDIATELY__ but expands the uniqueId argument first.
#define RUN_IMMEDIATELY_(statement, uniqueId) RUN_IMMEDIATELY__(statement, uniqueId)

/////////////////////////////////////////////////////////////
/// @brief Run a line of code as soon as execution starts, even before the main function gets control
///
/// @param statement The statement to execute at the start of the program
/////////////////////////////////////////////////////////////
#define RUN_IMMEDIATELY(statement) RUN_IMMEDIATELY_(statement, __LINE__)

/////////////////////////////////////////////////////////////
/// @brief Get the name to use 
/////////////////////////////////////////////////////////////
#define TEST_CLASSNAME(testGroupName, testName) testGroupName##_##testName

/////////////////////////////////////////////////////////////
/// @brief Declare a basic unit test
///
/// @param testGroupName the test group this test is part of
/// @param testName The name of this test
/////////////////////////////////////////////////////////////
#define BASIC_TEST(testGroupName, testName) \
    class TEST_CLASSNAME(testGroupName, testName) : public Test \
    { \
    public: \
        void runTest(); \
        const std::string& getTestName() const \
        { \
            static std::string name = #testName; \
            return name; \
        } \
        const std::string& getTestGroup() const \
        { \
                static std::string group = #testGroupName; \
                return group; \
        } \
    }; \
    RUN_IMMEDIATELY(TestManager::getInstance().registerTest(new TEST_CLASSNAME(testGroupName, testName)())); \
    \
    void TEST_CLASSNAME(testGroupName, testName)::runTest()

/////////////////////////////////////////////////////////////
/// @brief Declare a unit test with a fixture class
///
/// @param testGroupName the test group this test is part of
/// @param testName The name of this test
/// @param fixtureName The class to use as a fixture for this test
/////////////////////////////////////////////////////////////
#define FIXTURE_TEST(testGroupName, testName, fixtureName) \
    class TEST_CLASSNAME(testGroupName, testName) : public fixtureName \
    { \
    public: \
        void runTest(); \
        static const std::string& getTestName() \
        { \
            static std::string name = #testName; \
            return name; \
        } \
        static const std::string& getTestGroup() \
        { \
                static std::string group = #testGroupName; \
                return group; \
        } \
    }; \
    RUN_IMMEDIATELY(TestManager::getInstance().registerTest(new FixtureTest<TEST_CLASSNAME(testGroupName, testName)>())); \
    \
    void TEST_CLASSNAME(testGroupName, testName)::runTest()

/////////////////////////////////////////////////////////////
/// @brief Verify that a certain condition is true, and fail the current test if it is not
/// @note can be run from anywhere as long as it is indirectly within a test
///
/// @param condition The condition to check
/////////////////////////////////////////////////////////////
#define EXPECT(condition) \
    do \
    { \
        if(!(condition)) \
        { \
            TestManager::getInstance().failCurrentTest(); \
            std::cout << "  Assertion failed: " << #condition << std::endl; \
        } \
    } \
    while(0)

/////////////////////////////////////////////////////////////
/// @brief Verify that a statement throws an exception of a certain type, and fail the current test if it does not
/// @note can be run from anywhere as long as it is indirectly within a test
///
/// @param statement The statement that should throw an exception
/// @param exceptionType The type of the exception that it should throw
/////////////////////////////////////////////////////////////
#define EXPECT_THROW(statement, exceptionType) \
    do \
    { \
        try \
        { \
            statement; \
            TestManager::getInstance().failCurrentTest(); \
            std::cout << "  Assertion failed: exception \"" << #exceptionType << "\" missing" << std::endl; \
        } \
        catch(const exceptionType& e) \
        {} \
    } \
    while(0)

/////////////////////////////////////////////////////////////
/// @brief Verify that a certain condition is true, and fail the current test if it is not. Unlike EXPECT, ASSERT stops
///        the current test immediately if it fails.
/// @note can be run from anywhere as long as it is indirectly within a test
///
/// @param condition The condition to check
/////////////////////////////////////////////////////////////
#define ASSERT(condition) \
    do \
    { \
        if(!(condition)) \
        { \
            TestManager::getInstance().failCurrentTest(); \
            std::cout << "  Assertion failed: " << #condition << std::endl; \
            TestManager::getInstance().exitCurrentTest(); \
        } \
    } \
    while(0)

/////////////////////////////////////////////////////////////
/// @brief Verify that a statement throws an exception of a certain type, and fail the current test if it does not
///        Unlike EXPECT, ASSERT stops the current test immediately if it fails.
/// @note can be run from anywhere as long as it is indirectly within a test
///
/// @param statement The statement that should throw an exception
/// @param exceptionType The type of the exception that it should throw
/////////////////////////////////////////////////////////////
#define ASSERT_THROW(statement, exceptionType) \
    do \
    { \
        try \
        { \
            statement; \
            TestManager::getInstance().failCurrentTest(); \
            std::cout << "  Assertion failed: exception \"" << #exceptionType << "\" missing" << std::endl; \
            TestManager::getInstance().exitCurrentTest(); \
        } \
        catch(const exceptionType& e) \
        {} \
    } \
    while(0)

#endif